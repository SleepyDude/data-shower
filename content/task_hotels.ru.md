---
slug: "/test-task"
date: "2023-02-11"
title: "Test Task for Job"
---

# Задачи на сообразительность
## Задача 1
### Условие
Есть 90 человек. Каждый из этих 90 человек относится к одной из двух категорий. Одни на все вопросы говорят правду, другие — всегда врут. У каждого ровно 1 любимое блюдо из списка (макароны/пельмени/вареники). Каждому задают три вопроса:
-   *Ваше любимое блюдо — макароны?*
-   *Ваше любимое блюдо — пельмени?*
-   *Ваше любимое блюдо — вареники?*
Результаты получились такие:
-   на первый вопрос утвердительно ответило 45 человек,
-   на второй — 35,
-   на третий — 30.

**Сколько человек всегда говорят правду?**

### Решение

Обозначим общее количество людей, как $N$, а количество утвердительно ответивших на $1$,$2$ и $3$ вопрос, как $N_1$, $N_2$ и $N_3$ соответственно. 

Если бы все говорили только правду, то выполнялось бы равенство $N_1 + N_2 + N_3 = N$, однако из-за наличия лжецов неравенство не выполняется, имеем $N_1 + N_2 + N_3 > N$. Голос каждого лжеца учитывается дважды, так как он положительно отвечает 2 раза на вопрос о блюдах, которые не являются его любимыми (количество блюд - 1). 

Исходя из этого, количество лжецов равно избытку утвердительных ответов над общим количеством людей, а остальные - те, кто говорят правду.

Получается, что говорят правду $N - (N_1+N_2+N_3 - N)=90-(45+35+30 - 90)=70$ человек.

**Ответ: 70 человек говорят правду.**

## Задача 2
### Условие
Есть числа от трех до одиннадцати. Есть квадрат — 3 на 3 клетки

	а б в
	г д е
	ё ж з
(Буквы ничего не значат, кроме того, что числа не повторяются)
Можно ли расставить числа в клетки квадрата таким образом, что перемножения чисел в строках дает тот же результат, что и произведение чисел в столбцах с теми же номерами?
Если можно — расставьте, если нельзя — объясните почему.

### Решение

Если я правильно понял, то для квадрата должны выполняться условия:
$$а\times б\times в = а \times г \times ё$$
$$г\times д\times е = б \times д \times ж$$
$$ё\times ж\times з = в \times е \times з$$
Что упрощается до:
$$б\times в = г \times ё$$
$$г\times е = б \times ж$$
$$ё\times ж = в \times е$$

Рассмотрим условие выполнения одной такой строки.
$$б\times в = г \times ё = M$$
В множесте доступных чисел должно быть 2 пары таких, чтобы при перемножении они давали одно число $M$. $M$ может быть разложено на произведение простых чисел. Наименьшим для нашего множества будет $M$, которое раскладывается на числа {$3, 3, 3$}, но из него составляется только одна пара $3 \times 9$. Наименьшая комбинация из которой составляется 2 разных пары - {$3, 3, 4$}, что дает:
$$M = 3 \cdot 3 \times 4 = 9 \times 4$$ 
$$M = 3 \times 3 \cdot 4 = 3 \times 12$$
Видим, что необходимо иметь в множесте число 12, которое выходит за пределы множества доступных чисел.

**Таким образом, заполнение всего квадрата также является невозможным.**

## Задача 3
### Условие
Ученые разработали новый материал неизвестной прочности. Они знают, что материал разбивается при падении с высоты от 1 метра до 5 000 метров. Но не знают, с какой именно высоты. Чтобы определить прочность, ученые поднимают предмет на некоторую высоту и сбрасывают его оттуда. Их задача — определить, начиная с какой именно высоты предмет начнет разбиваться.

Специальная платформа, с помощью которой они осуществляют эксперимент, скидывает предмет только с дискретных высот (1, 2, 3 ... 4999, 5000 метров — платформа не может скинуть предмет, например, с 2,5 метров. Точности в 1 метр ученым вполне достаточно). При падении с высоты "n" метров предмет уничтожается. Если же его сбрасывали с высоты ниже "n", то его можно использовать в повторных экспериментах.

Нужно АБСОЛЮТНО ТОЧНО найти ту высоту, начиная с которой предметы разрушаются. Сделать это нужно за МИНИМАЛЬНО возможное число экспериментов. У ученых при этом всего 2 предмета, но они абсолютно одинаковые. Каким образом этого можно достигнуть? Сколько экспериментов при этом максимально потребуется?

### Решение
Пусть N - максимальная высота.

*TLDR: Первым предметом разделяем высоту на сегменты и находим тот, в котором находится искомая высота. Вторым предметом исследуем подробно найденный сегмент. Оптимальное разделение на сегменты достигается, если интервал постепенно уменьшать, тогда для каждого сегмента будем иметь одинаковый худший случай. Зависимость числа экспериментов от высоты N в худшем случае выражается формулой $E_{min}(N)=\sqrt{2 \cdot N} - 0.5$ Для 5000 метров получаем 100 экспериментов.*

**Подробное объяснение:**

#### Роль первого предмета
Каждый раз бросая первый предмет с высоты $N_k, \; N_k < N$, мы ограничиваем дальнейшую область исследования. Если предмет разбился, то искомый этаж ниже, если остался цел - выше. Таким образом, бросая первый предмет поочередно с высот $0 < N_1 < N_2 < ... < N_{k-1} < N_k < ... < N_n < N$ и обнаружив, что он разбился при броске $N_k$, понимаем, что искомая искомая высота расположена в полуинтервале $(N_{k-1};N_k]$. Так как первый предмет разбит, то далее для исследования интервала используется второй предмет.

Максимальное количество экспериментов **n** зависит от выбора разбиения на интервалы.

#### Роль второго предмета
Имея выделенный полуинтервал $(N_{k-1};N_k]$ и один предмет, единственным способом точного определения искомой высоты является бросание его поочередно на каждой высоте, начиная с наименьшей, в открытом интервале $(N_{k-1};N_k)$, то есть $m = N_k - N_{k-1}-1$ бросок. Один бросок может сэкономить, так как, если второй предмет не разбивается на всех экспериментах, то единственным вариантом остаётся высота $N_k$

Максимальное колчество экспериментов **m** зависит от ширины интервала.

#### Подходы к решению задачи

Общее количество экспериментов в худшем случае будем обозначать $E$, оно складывается из количества бросков первого и второго предмета в худших случаях. $$E=n+m$$

##### Равные интервалы
Рассмотрим сначала разбиение высоты на $n+1$ равновеликих интервалов. Допустим, что $N$ без остатка делится на $n+1$.

Это можно сделать за $n$ бросков 1 предмета и $m = \frac{N}{n+1}-1$ бросков предмета №2. То есть число экспериментов как функция бросков 1 предмета:
$$E(n)=n+\frac{N}{n+1}-1$$
Для данной модели можно провести расчет и выяснить оптимальное количество $n$ при котором достигается минимум $E(n)$
$$n_{min}=\sqrt{N}-1$$
$$E_{min}(n)=2 \cdot \sqrt{N}-2$$

Однако, заметим, что подход равных интервалов не является оптимальным. Худший случай всегда достигается, если искомая высота равна N, так как необходимо максимальное количество бросков как первого так и второго предмета для её нахождения.

##### Уменьшающиеся интервалы
Есть возможность улучшить ситуацию, если сделать длину интервалов различной - предыдущие будут шире, чем последующие. Таким образом, общее количество экспериментов будет одинаковым для каждого интервала в худшем случае, и максимальное количество шагов как бы перераспределится с последнего интервала на остальные, тем самым уменьшившись в целом.

Будем искать такое разделение исходя из условия равного количества экспериментов $E$ в худшем случае для каждого интервала. 

$$E_k=k+(N_k - N_{k-1}-1),\; где \; k - номер \; интервала$$
Все $E_k$ равны между собой, разделение происходит на некоторое $n+1$ количество интервалов. Также будем считать, что проверка высоты N обязательна.
$$E=1+(N_1 - 0 - 1) = 2+(N_2-N_1-1)=3+(N_3-N_2-1)=...=k+(N_k - N_{k-1}-1)=...$$
$$=n+(N_n-N_{n-1}-1)=n+(N-N_n)$$

Заметим, что $E=N1$

Перейдём к обозначению длин интервалов, все они могут быть выражены через первый.
$$E=\Delta_1=N_1$$
$$\Delta_2=N_2-N_1=N_1-1$$
$$\Delta_3=N_3-N_2=N_1-2$$
$$\Delta_k=N_k-N_{k-1}=N_1-k+1$$
$$\Delta_n=N_n-N_{n-1}=N_1-n+1$$
$$\Delta_{n+1}=N-N_n=N_1-n$$
Также примем во внимание условие
$$\Delta_1+\Delta_2+...+\Delta_k+...+\Delta_{n+1}=N$$

Найдем зависимость $E$ от числа разбиения $n$
$$(n+1)\cdot E - (0 + 1 + 2 + ... + n)=N$$
Имеем $n+1$ слагаемых в скобках, следовательно
$$(n+1)\cdot E - \frac{n\cdot (n+1)}{2}=N$$
Выразим число экспериментов $E(n)$, как функцию от $n$
$$E(n)=\frac{N}{n+1} + \frac{n}{2}$$

Определим оптимальное количество интервалов $n+1$,  взяв производную и приравняв к нулю
$$E'(n) = 0 = -\frac{N}{(n+1)^2} + \frac{1}{2}$$
=>
$$n_{min} = \sqrt{2 \cdot N} - 1$$
$$E_{min}(N)=\sqrt{2 \cdot N} - 0.5$$

Сравнивая минимальное количество экспериментов для равномерных и уменьшающихся интервалов видим, что для максимальной высоты более 7 метров метод с уменьшающимися интервалами выигрывает.
$$E^{равн}_{min}(n)=2 \cdot \sqrt{N}-2$$
$$E^{уменьш}_{min}(N)=\sqrt{2 \cdot N} - 0.5$$
В пределе при очень большой максимальной высоте фактор оптимизации составляет $\sqrt{2}$

##### Рекурсивный метод

Метод с уменьшающимися интервалами можно оптимизировать. Это не изменит худшего случая, но улучшит средний.
Предполагается выполнение итерационной процедуры после вычисления каждого броска первого предмета, то есть каждый раз вычислять $N_1(N')$, где $N'$ - оставшееся число метров до максимальной высоты $N$.

При сокращении N' до размера менее 7 следует использовать равномерное разбиение интервалов.

Обозначим за $N'_k$ - оставшеесяя количество высоты при $k$-м броске 2го предмета, тогда

$$N_1 = \sqrt{2N}-0.5$$
$$N_2 = \sqrt{2(N-N_1)}-0.5$$
$$N_3 = \sqrt{2(N-N_2)}-0.5$$
$$N_k = \sqrt{2(N-N_{k-1})}-0.5$$

Видим, что получается рекурентная формула, такой способ должен показывать более высокую эффективность в среднем.

#### Вывод

Расчет минимального числа экспериментов производится по формуле для метода уменьшающихся интервалов
$$E^{уменьш}_{min}(N)=\sqrt{2 \cdot N} - 0.5$$
И для $N=5000$ метров получаем 99.5 экспериментов, что округляется до **100**

Для сравнения, метод равных интервалов давал бы оптимальное значение **140**

Ответ: Эффективного определения высоты, на которой предмет абсолютно точно разбивается, можно добиться используя **метод с уменьшающимся интервалом** и для высоты 5000 метров понадобится **100 экспериментов**.

## Задача 4
### Условие
В университетскую столовую пришли трое студентов купить пирожки. Один хочет купить треть всех имеющихся в столовой пирожков и еще 2 пирожка. Другой хочет купить четверть от всех имеющихся пирожков и ещё 3 пирожка. А третий хочет купить пятую часть всех пирожков и ещё 8 пирожков. Если все трое купят столько пирожков, сколько планируют, то в столовой как раз закончатся все пирожки. Сколько пирожков есть в столовой?

### Решение
Пусть всего в столовой $X$ пирожков. Тогда по условию задачи составляется уравнение:
$$\frac{X}{3} + 2 + \frac{X}{4} + 3 + \frac{X}{5} + 8 = X$$
Решим его и получим, что $X=60$

# Задачи по программированию

## Задача 1
Написать метод/функцию, который/которая на вход принимает массив городов. В качестве результата возвращает строку, где города разделены запятыми, а в конце стоит точка. 

>Пример:
>«Москва, Санкт-Петербург, Воронеж.»**

```python
# task 1. time ~1 min
def towns_to_str(towns: list):
    return ', '.join(towns) + '.'

# test
towns = ['Moscow', 'Vladimir', 'Paris']
assert(towns_to_str(towns) == 'Moscow, Vladimir, Paris.')
```

## Задача 2
Написать метод/функцию, который/которая на вход принимает число (float), а на выходе получает число, округленное до пятерок.
>Пример:
>27 => 25, 27.8 => 30, 41.7 => 40.

```python
# task 2. time ~3 min
def round5(num: float):
    return (num + 2.5) // 5 * 5

# test
assert(round5(2.1) == 0)
assert(round5(2.7) == 5)
assert(round5(27) == 25)
assert(round5(27.8) == 30)
assert(round5(41.7) == 40)
```
## Задача 3
Написать метод/функцию, который/которая на вход принимает число (int), а на выходе выдает слово “компьютер” в падеже, соответствующем указанному количеству.
>Пример:
>«25 компьютеров», «41 компьютер», «1048 компьютеров».

```python
# task 3. time ~ 10 min
def computer_print(num: int):
    last_digit = int(str(num)[-1])
    last_two_digits = int(str(num)[-2:])
    if last_digit >= 5 or last_digit == 0 or (last_two_digits > 10 and last_two_digits < 20):
        return str(num) + ' компьютеров'
    if last_digit == 1:
        return str(num) + ' компьютер'
    if last_digit > 1 and last_digit < 5:
        return str(num) + ' компьютера'

# test
assert(computer_print(16) == '16 компьютеров')
assert(computer_print(818) == '818 компьютеров')
assert(computer_print(1995) == '1995 компьютеров')
assert(computer_print(11) == '11 компьютеров')
assert(computer_print(21) == '21 компьютер')
assert(computer_print(4) == '4 компьютера')
assert(computer_print(1023) == '1023 компьютера')
assert(computer_print(0) == '0 компьютеров')
```
## Задача 4
Написать метод/функцию, который/которая на вход принимает целое число, а на выходе возвращает то, является ли число простым (не имеет делителей кроме 1 и самого себя).

```python
# task 4, time - 1 ночь на поиск способа считать без перебора. Не нашел
from math import sqrt

def is_prime(num: int):
    if num % 2 == 0:
        return False
    for i in range(3, int(sqrt(num)) + 1, 2):
        if num % i == 0:
            return False
    return True

# test
assert(is_prime(71) == True)
assert(is_prime(73) == True)
assert(is_prime(121) == False)
```
## Задача 5
Написать метод, который определяет, какие элементы присутствуют в двух экземплярах в каждом из массивов (= в двух и более, причем в каждом). На вход подаются два массива. На выходе массив с необходимыми совпадениями.
>Пример:
>[7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1]
>На выходе [1, 17]

```python
# task 5. time ~ 10 min
def doubles(arr_1: list, arr_2: list) -> list:
    dict_1 = { i: 0 for i in arr_1 }
    dict_2 = { i: 0 for i in arr_2 }
    for num in arr_1:
        dict_1[num] += 1
    for num in arr_2:
        dict_2[num] += 1
    doubles_1 = { key for key in dict_1 if dict_1[key] >= 2 }
    doubles_2 = { key for key in dict_2 if dict_2[key] >= 2 }
    return list(doubles_1.intersection(doubles_2))

# test
list_1 = [7, 17, 1, 9, 1, 17, 56, 56, 23]
list_2 = [56, 17, 17, 1, 23, 34, 23, 1, 8, 1]
res = doubles(list_1, list_2)
assert(len(res) == 2)
assert(17 in res and 1 in res)
```
## Задача 6
Написать метод, который в консоль выводит таблицу умножения. На вход метод получает число, до которого выводит таблицу умножения. В консоли должна появиться таблица. 
```python
# task 6, time ~ 30 min.
def multiply_table(num: int) -> str:
    # calculate widths
    col_widths = []
    for i in range(1, num+1):
        col_widths.append(len(str(i*num)))
    lines = []
    for i in range(1, num+1):
        line_parts = []
        for j in range(1, num+1):
            n = i*j
            item = ' ' * (col_widths[j-1] - len(str(n))) + str(n)
            line_parts.append(item)
        lines.append(line_parts)
    # construct left and top side
    result = ' ' * col_widths[0] + '  ' + ' '.join(lines[0]) + '\n'
    result += ' ' * col_widths[0] + '  ' + '-'*len(' '.join(lines[0])) + '\n'
    for line_parts in lines:
        result += line_parts[0] + ' |' + ' '.join(line_parts) + '\n'
    return result

# test
res = multiply_table(25)
print(res)
```